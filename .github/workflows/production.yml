name: Production CI/CD Pipeline - Lerna Monorepo

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy all services (skip change detection)'
        required: false
        default: 'false'
        type: boolean
      service:
        description: 'Deploy specific service only'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - api_gateway
          - auth_service
          - ai_service
          - company_service
          - customer_service
          - dashboard_service
          - email_service
          - invoice_service
          - pdf_service
          - product_service
          - quote_service
          - stripe_service

env:
  REGISTRY: ghcr.io
  NODE_VERSION: '20'

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  # 1. DÉTECTION DES CHANGEMENTS AVEC LERNA
  detect-changes:
    name: "🔍 Detect Changes (Lerna)"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      changed_packages: ${{ steps.lerna-changes.outputs.packages }}
      has_changes: ${{ steps.has-changes.outputs.result }}
      shared_changed: ${{ steps.changes.outputs.shared }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Nécessaire pour Lerna

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install root dependencies
        run: |
          npm ci --no-audit --no-fund
          echo "📦 Root dependencies installed"

      - name: Detect file changes (fallback)
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            shared:
              - 'packages/shared/**'
            root:
              - 'package.json'
              - 'lerna.json'
              - '.github/workflows/**'

      - name: Detect changed packages with Lerna
        id: lerna-changes
        run: |
          # Function to convert package names to folder names (tiret -> underscore)
          convert_to_folder_name() {
            echo "$1" | sed 's/-/_/g'
          }
          
          if [[ "${{ github.event.inputs.service }}" != "all" && "${{ github.event.inputs.service }}" != "" ]]; then
            # Déploiement manuel d'un service spécifique
            echo "packages=[\"${{ github.event.inputs.service }}\"]" >> $GITHUB_OUTPUT
            echo "🎯 Manual deployment: ${{ github.event.inputs.service }}"
          elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            # Force deploy tous les services
            PACKAGES=$(find packages -maxdepth 1 -type d -name "*_service" -o -name "api_gateway" | xargs -I {} basename {} | jq -R . | jq -s .)
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "🚀 Force deploy all services"
          else
            # Utilisation de Lerna pour détecter les changements
            if command -v npx >/dev/null 2>&1 && npx lerna changed --json 2>/dev/null | jq empty 2>/dev/null; then
              CHANGED=$(npx lerna changed --json 2>/dev/null || echo "[]")
              if [[ "$CHANGED" == "[]" ]] && [[ "${{ steps.changes.outputs.shared }}" == "true" || "${{ steps.changes.outputs.root }}" == "true" ]]; then
                # Si shared ou root a changé, rebuilder tous les services
                PACKAGES=$(find packages -maxdepth 1 -type d -name "*_service" -o -name "api_gateway" | xargs -I {} basename {} | jq -R . | jq -s .)
                echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
                echo "📦 Shared/root changes detected, rebuilding all services"
              else
                # Convertir les noms de packages (avec tirets) vers les noms de dossiers (avec underscores)
                PACKAGES_CONVERTED="[]"
                if [[ "$CHANGED" != "[]" ]]; then
                  PACKAGES_CONVERTED=$(echo "$CHANGED" | jq -r '.[].name' | while read -r pkg_name; do
                    folder_name=$(convert_to_folder_name "$pkg_name")
                    # Vérifier que le dossier existe
                    if [[ -d "packages/$folder_name" ]]; then
                      echo "$folder_name"
                    else
                      echo "⚠️  Warning: Package $pkg_name -> $folder_name not found in packages/" >&2
                    fi
                  done | jq -R . | jq -s .)
                fi
                echo "packages=$PACKAGES_CONVERTED" >> $GITHUB_OUTPUT
                echo "📦 Changed packages detected: $PACKAGES_CONVERTED"
              fi
            else
              # Fallback : utiliser la détection de fichiers si Lerna n'est pas disponible
              if [[ "${{ steps.changes.outputs.shared }}" == "true" || "${{ steps.changes.outputs.root }}" == "true" ]]; then
                PACKAGES=$(find packages -maxdepth 1 -type d -name "*_service" -o -name "api_gateway" | xargs -I {} basename {} | jq -R . | jq -s .)
                echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
                echo "📦 Fallback: Shared/root changes detected, rebuilding all services"
              else
                echo "packages=[]" >> $GITHUB_OUTPUT
                echo "✅ No packages changed (Lerna unavailable, using file detection)"
              fi
            fi
          fi

      - name: Check if deployment needed
        id: has-changes
        run: |
          PACKAGES="${{ steps.lerna-changes.outputs.packages }}"
          if [[ "$PACKAGES" != "[]" && "$PACKAGES" != "" ]]; then
            echo "result=true" >> $GITHUB_OUTPUT
            echo "📦 Deployment needed for: $PACKAGES"
          else
            echo "result=false" >> $GITHUB_OUTPUT
            echo "✅ No deployment needed"
          fi

      - name: Set matrix for parallel jobs
        id: set-matrix
        run: |
          PACKAGES="${{ steps.lerna-changes.outputs.packages }}"
          echo "matrix={\"service\":$PACKAGES}" >> $GITHUB_OUTPUT

  # 2. BUILD INDÉPENDANT PAR SERVICE
  build:
    name: "🏗️ Build"
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.detect-changes.outputs.matrix) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install root dependencies
        run: |
          npm ci --no-audit --no-fund
          echo "📦 Root dependencies installed"

      - name: Build shared package (if needed)
        if: needs.detect-changes.outputs.shared_changed == 'true' || github.event.inputs.force_deploy == 'true'
        run: |
          if [ -d "packages/shared" ]; then
            echo "🔧 Building shared package..."
            cd packages/shared
            npm ci --no-audit --no-fund
            if npm run 2>&1 | grep -q "build$"; then
              npm run build
              echo "✅ Shared package built successfully"
            else
              echo "ℹ️  No build script for shared package"
            fi
            cd ../..
          fi

      - name: Build service
        run: |
          SERVICE="${{ matrix.service }}"
          echo "🔧 Building $SERVICE..."
          
          cd packages/$SERVICE
          npm ci --no-audit --no-fund
          
          # Vérifier si un script de build existe
          if npm run 2>&1 | grep -q "build$"; then
            echo "📦 Running build for $SERVICE..."
            npm run build
            echo "✅ $SERVICE built successfully"
            
            # Vérifier que le build a produit des fichiers
            if [ -d "dist" ]; then
              echo "📂 Build artifacts created in dist/"
              ls -la dist/
            else
              echo "⚠️  No dist/ directory created"
            fi
          else
            echo "ℹ️  No build script for $SERVICE, using source files directly"
          fi

      - name: Cache build artifacts
        uses: actions/cache/save@v3
        with:
          path: |
            packages/${{ matrix.service }}/dist
            packages/${{ matrix.service }}/node_modules
            packages/shared/dist
            packages/shared/node_modules
          key: build-${{ matrix.service }}-${{ github.sha }}

  # 3. TESTS PAR SERVICE
  test:
    name: "🧪 Test"
    runs-on: ubuntu-latest
    needs: [detect-changes, build]
    if: needs.detect-changes.outputs.has_changes == 'true'
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.detect-changes.outputs.matrix) }}
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        options: >-
          --health-cmd "pg_isready -U test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Restore build cache
        uses: actions/cache/restore@v3
        with:
          path: |
            packages/${{ matrix.service }}/dist
            packages/${{ matrix.service }}/node_modules
            packages/shared/dist
            packages/shared/node_modules
          key: build-${{ matrix.service }}-${{ github.sha }}

      - name: Install dependencies (if cache miss)
        run: |
          if [ ! -d "packages/${{ matrix.service }}/node_modules" ]; then
            npm ci --no-audit --no-fund
            cd packages/${{ matrix.service }}
            npm ci --no-audit --no-fund
          fi

      - name: Run tests
        run: |
          cd packages/${{ matrix.service }}
          if npm run 2>&1 | grep -q "test$"; then
            echo "🧪 Running tests for ${{ matrix.service }}..."
            npm test
            echo "✅ Tests passed for ${{ matrix.service }}"
          else
            echo "ℹ️  No tests for ${{ matrix.service }}"
          fi
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379

  # 4. SECURITY SCAN (une seule fois)
  security:
    name: "🔒 Security Scan"
    runs-on: ubuntu-latest
    needs: [detect-changes, test]
    if: needs.detect-changes.outputs.has_changes == 'true'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --no-audit --no-fund

      - name: Run security audit
        run: |
          npm audit --audit-level=high
          echo "🔒 Security audit completed"

      - name: Check for secrets
        run: |
          # Vérification des secrets dans le code
          if grep -r -E "(STRIPE_SECRET_KEY|OPENAI_API_KEY|DATABASE_URL|BETTER_AUTH_SECRET)" \
             --include="*.ts" --include="*.js" --exclude-dir=node_modules \
             --exclude-dir=dist packages/; then
            echo "❌ Secrets found in code!"
            exit 1
          fi
          echo "✅ No secrets found in code"

  # 5. BUILD & PUSH DOCKER IMAGES PAR SERVICE
  push:
    name: "🐳 Push"
    runs-on: ubuntu-latest
    needs: [detect-changes, build, test, security]
    if: needs.detect-changes.outputs.has_changes == 'true' && github.ref == 'refs/heads/main'
    timeout-minutes: 20
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix: ${{ fromJSON(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Restore build cache
        uses: actions/cache/restore@v3
        with:
          path: |
            packages/${{ matrix.service }}/dist
            packages/${{ matrix.service }}/node_modules
            packages/shared/dist
            packages/shared/node_modules
          key: build-${{ matrix.service }}-${{ github.sha }}

      - name: Rebuild if cache miss
        run: |
          # Rebuild shared if needed
          if [ -d "packages/shared" ] && [ ! -d "packages/shared/node_modules" ]; then
            cd packages/shared
            npm ci --no-audit --no-fund
            if npm run 2>&1 | grep -q "build$"; then
              npm run build
            fi
            cd ../..
          fi
          
          # Rebuild service if needed
          cd packages/${{ matrix.service }}
          if [ ! -d "node_modules" ]; then
            npm ci --no-audit --no-fund
          fi
          if [ ! -d "dist" ] && npm run 2>&1 | grep -q "build$"; then
            npm run build
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/zenbillingapp/zenbilling-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: packages/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

  # 6. DÉPLOIEMENT COOLIFY PAR SERVICE
  deploy:
    name: "🚀 Deploy to Coolify"
    runs-on: ubuntu-latest
    needs: [detect-changes, push]
    if: needs.detect-changes.outputs.has_changes == 'true' && github.ref == 'refs/heads/main'
    timeout-minutes: 15
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix: ${{ fromJSON(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: Deploy to Coolify
        run: |
          SERVICE="${{ matrix.service }}"
          SERVICE_UPPER=$(echo "$SERVICE" | tr '[:lower:]' '[:upper:]')
          WEBHOOK_VAR="COOLIFY_WEBHOOK_${SERVICE_UPPER}"
          WEBHOOK_URL="${!WEBHOOK_VAR}"
          
          if [ -z "$WEBHOOK_URL" ]; then
            echo "❌ Webhook URL not found for $SERVICE"
            echo "Expected environment variable: $WEBHOOK_VAR"
            exit 1
          fi
          
          echo "🚀 Deploying $SERVICE to Coolify..."
          echo "📡 Using webhook: $WEBHOOK_URL"
          
          # Déploiement avec retry
          for attempt in {1..3}; do
            echo "🔄 Deployment attempt $attempt for $SERVICE..."
            
            if curl -f -s --max-time 180 "$WEBHOOK_URL"; then
              echo "✅ Deployment webhook sent successfully for $SERVICE"
              break
            else
              echo "❌ Deployment attempt $attempt failed for $SERVICE"
              if [ $attempt -eq 3 ]; then
                echo "💥 All deployment attempts failed for $SERVICE"
                exit 1
              fi
              echo "⏳ Waiting 30s before retry..."
              sleep 30
            fi
          done
          
          echo "⏳ Waiting for $SERVICE deployment to start..."
          sleep 45
        env:
          COOLIFY_WEBHOOK_API_GATEWAY: ${{ secrets.COOLIFY_WEBHOOK_API_GATEWAY }}
          COOLIFY_WEBHOOK_AUTH_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_AUTH_SERVICE }}
          COOLIFY_WEBHOOK_AI_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_AI_SERVICE }}
          COOLIFY_WEBHOOK_COMPANY_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_COMPANY_SERVICE }}
          COOLIFY_WEBHOOK_CUSTOMER_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_CUSTOMER_SERVICE }}
          COOLIFY_WEBHOOK_DASHBOARD_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_DASHBOARD_SERVICE }}
          COOLIFY_WEBHOOK_EMAIL_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_EMAIL_SERVICE }}
          COOLIFY_WEBHOOK_INVOICE_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_INVOICE_SERVICE }}
          COOLIFY_WEBHOOK_PDF_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_PDF_SERVICE }}
          COOLIFY_WEBHOOK_PRODUCT_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_PRODUCT_SERVICE }}
          COOLIFY_WEBHOOK_QUOTE_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_QUOTE_SERVICE }}
          COOLIFY_WEBHOOK_STRIPE_SERVICE: ${{ secrets.COOLIFY_WEBHOOK_STRIPE_SERVICE }}

  # 7. HEALTH CHECK DES SERVICES DÉPLOYÉS
  health-check:
    name: "🏥 Health Check"
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy]
    if: needs.detect-changes.outputs.has_changes == 'true' && github.ref == 'refs/heads/main'
    timeout-minutes: 10

    steps:
      - name: Wait for services startup
        run: |
          echo "⏳ Waiting for deployed services to start..."
          sleep 90

      - name: Health check deployed services
        run: |
          BASE_URL="${{ secrets.COOLIFY_BASE_URL }}"
          if [[ -z "$BASE_URL" ]]; then
            echo "❌ COOLIFY_BASE_URL secret not configured"
            exit 1
          fi

          DEPLOYED_SERVICES='${{ needs.detect-changes.outputs.changed_packages }}'
          echo "🔍 Checking health of deployed services: $DEPLOYED_SERVICES"

          failed_services=()
          
          # Parse JSON array of deployed services
          for service in $(echo "$DEPLOYED_SERVICES" | jq -r '.[]'); do
            # Skip api_gateway for service-specific health checks
            if [[ "$service" == "api_gateway" ]]; then
              continue
            fi
            
            url="$BASE_URL/api/${service}/health"
            echo "🔍 Checking $service at $url"
            
            if curl -f -s --max-time 15 "$url" > /dev/null; then
              echo "✅ $service is healthy"
            else
              echo "❌ $service health check failed"
              failed_services+=("$service")
            fi
          done

          # Check API Gateway if deployed
          if echo "$DEPLOYED_SERVICES" | jq -r '.[]' | grep -q "api_gateway"; then
            echo "🔍 Checking API Gateway at $BASE_URL/"
            if curl -f -s --max-time 15 "$BASE_URL/" > /dev/null; then
              echo "✅ API Gateway is healthy"
            else
              echo "❌ API Gateway health check failed"
              failed_services+=("api_gateway")
            fi
          fi

          # Report results
          if [ ${#failed_services[@]} -gt 0 ]; then
            echo "❌ Health checks failed for: ${failed_services[*]}"
            echo "🔍 Check Coolify logs for more details"
            exit 1
          else
            echo "🎉 All deployed services are healthy!"
          fi

  # 8. NOTIFICATION ET CLEANUP
  cleanup:
    name: "🧹 Cleanup & Notify"
    runs-on: ubuntu-latest
    needs: [detect-changes, health-check]
    if: always() && needs.detect-changes.outputs.has_changes == 'true'
    
    steps:
      - name: Report deployment status
        run: |
          DEPLOYED_SERVICES='${{ needs.detect-changes.outputs.changed_packages }}'
          
          if [[ "${{ needs.health-check.result }}" == "success" ]]; then
            echo "🎉 ✅ Deployment completed successfully!"
            echo "🚀 Deployed services: $DEPLOYED_SERVICES"
            echo "📊 Workflow summary:"
            echo "  - Build: ${{ needs.build.result }}"
            echo "  - Test: ${{ needs.test.result }}"
            echo "  - Security: ${{ needs.security.result }}"
            echo "  - Push: ${{ needs.push.result }}"
            echo "  - Deploy: ${{ needs.deploy.result }}"
            echo "  - Health: ${{ needs.health-check.result }}"
          else
            echo "❌ ⚠️  Deployment failed or health checks failed"
            echo "🔍 Check the logs above for more details"
            echo "📋 Deployed services: $DEPLOYED_SERVICES"
            
            # En cas d'échec, indiquer les étapes pour le rollback
            echo "🔄 To rollback, run the rollback workflow manually"
          fi
          
      - name: Clean up old artifacts
        run: |
          echo "🧹 Cleanup completed (caches are automatically managed by GitHub Actions)"